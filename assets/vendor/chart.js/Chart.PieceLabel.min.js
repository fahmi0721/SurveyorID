/**
 * [Chart.PieceLabel.js]{@link https://github.com/beaver71/Chart.PieceLabel.js}
 *
 * @version 0.9.1
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2017
 * @forkedby Beaver71 2017
 * @license MIT
 */
! function() {
    if ("undefined" != typeof Chart) {
        t.prototype.beforeDatasetsUpdate = function(t) {
            if (this.parseOptions(t) && "outside" === this.position) {
                var e = 1.5 * this.fontSize + 2;
                this.segment && (e += 20), t.chartArea.top += e, t.chartArea.bottom -= e
            }
        }, t.prototype.afterDatasetsDraw = function(t) { this.parseOptions(t) && (this.labelBounds = [], t.config.data.datasets.forEach(this.drawDataset)) }, t.prototype.drawDataset = function(t) {
            for (var e = this.ctx, i = this.chartInstance, o = t._meta[Object.keys(t._meta)[0]], s = 0, a = 0; a < o.data.length; a++) {
                var r, n = o.data[a],
                    h = n._view;
                if (0 !== h.circumference || this.showZero) {
                    switch (this.render) {
                        case "value":
                            var l = t.data[a];
                            this.format && (l = this.format(l)), r = l.toString();
                            break;
                        case "label":
                            r = i.config.data.labels[a];
                            break;
                        case "image":
                            r = this.images[a] ? this.loadImage(this.images[a]) : "";
                            break;
                        case "percentage":
                        default:
                            var f = h.circumference / this.options.circumference * 100;
                            f = parseFloat(f.toFixed(this.precision)), this.showActualPercentages || (s += f) > 100 && (f -= s - 100, f = parseFloat(f.toFixed(this.precision))), r = f + "%"
                    }
                    if ("function" == typeof this.render && "object" == typeof(r = this.render({ label: i.config.data.labels[a], value: t.data[a], percentage: f, dataset: t, index: a })) && (r = this.loadImage(r)), !r) return;
                    var c, d, p;
                    if (e.save(), e.beginPath(), e.font = Chart.helpers.fontString(this.fontSize, this.fontStyle, this.fontFamily), "outside" === this.position || "border" === this.position && "pie" === i.config.type) {
                        d = h.outerRadius / 2;
                        var u, g = this.fontSize + 2,
                            x = h.startAngle + (h.endAngle - h.startAngle) / 2;
                        "border" === this.position ? u = (h.outerRadius - d) / 2 + d : "outside" === this.position && (this.segment && (g = 20), u = h.outerRadius - d + d + g), c = { x: h.x + Math.cos(x) * u, y: h.y + Math.sin(x) * u }, "outside" === this.position && (c.x < h.x ? c.x -= g : c.x += g, p = h.outerRadius + g)
                    } else d = h.innerRadius, c = n.tooltipPosition();
                    var y = this.fontColor;
                    if ("function" == typeof y ? y = y({ label: i.config.data.labels[a], value: t.data[a], percentage: f, text: r, backgroundColor: t.backgroundColor[a], dataset: t, index: a }) : "string" != typeof y && (y = y[a] || this.options.defaultFontColor), this.arc) p || (p = (d + h.outerRadius) / 2), e.fillStyle = y, e.textBaseline = "middle", this.drawArcText(r, p, h, this.overlap);
                    else {
                        var m, b = this.measureText(r),
                            v = c.x - b.width / 2,
                            w = c.x + b.width / 2,
                            S = c.y - this.fontSize / 2,
                            T = c.y + this.fontSize / 2;
                        if (this.overlap) m = !0;
                        else if ("outside" === this.position) {
                            if (this.segment) {
                                start = { x: h.x + Math.cos(x) * h.outerRadius, y: h.y + Math.sin(x) * h.outerRadius };
                                var C = u - 10;
                                if (end = { x: h.x + Math.cos(x) * C, y: h.y + Math.sin(x) * C }, e.beginPath(), e.moveTo(start.x, start.y), "auto" == this.segmentColor) var A = h.backgroundColor;
                                else A = this.segmentColor;
                                e.strokeStyle = A, e.lineWidth = 1, e.lineTo(end.x, end.y), start.x < end.x ? (c.x = c.x + 10, end.x = c.x - b.width / 2 - 1) : (c.x = c.x - 10, end.x = c.x + b.width / 2 + 1), v = c.x - b.width / 2, w = c.x + b.width / 2, S = c.y - this.fontSize / 2, T = c.y + this.fontSize / 2, e.lineTo(end.x, end.y), e.stroke()
                            }
                            m = this.checkTextBound(v, w, S, T)
                        } else m = n.inRange(v, S) && n.inRange(v, T) && n.inRange(w, S) && n.inRange(w, T);
                        m && this.fillText(r, c, y)
                    }
                    e.restore()
                }
            }
        }, t.prototype.parseOptions = function(t) { var e = t.options.pieceLabel; return !!e && (this.chartInstance = t, this.ctx = t.chart.ctx, this.options = t.config.options, this.render = e.render || e.mode, this.position = e.position || "default", this.arc = e.arc, this.format = e.format, this.precision = e.precision || 0, this.fontSize = e.fontSize || this.options.defaultFontSize, this.fontColor = e.fontColor || this.options.defaultFontColor, this.fontStyle = e.fontStyle || this.options.defaultFontStyle, this.fontFamily = e.fontFamily || this.options.defaultFontFamily, this.hasTooltip = t.tooltip._active && t.tooltip._active.length, this.showZero = e.showZero, this.overlap = e.overlap, this.images = e.images || [], this.showActualPercentages = e.showActualPercentages || !1, this.segment = e.segment || !1, this.segmentColor = e.segmentColor || "auto", !0) }, t.prototype.checkTextBound = function(t, e, i, o) {
            for (var s = this.labelBounds, a = 0; a < s.length; ++a) {
                for (var r = s[a], n = [
                        [t, i],
                        [t, o],
                        [e, i],
                        [e, o]
                    ], h = 0; h < n.length; ++h) {
                    var l = n[h][0],
                        f = n[h][1];
                    if (l >= r.left && l <= r.right && f >= r.top && f <= r.bottom) return !1
                }
                n = [
                    [r.left, r.top],
                    [r.left, r.bottom],
                    [r.right, r.top],
                    [r.right, r.bottom]
                ];
                for (h = 0; h < n.length; ++h) { l = n[h][0], f = n[h][1]; if (l >= t && l <= e && f >= i && f <= o) return !1 }
            }
            return s.push({ left: t, right: e, top: i, bottom: o }), !0
        }, t.prototype.measureText = function(t) { return "object" == typeof t ? { width: t.width, height: t.height } : this.ctx.measureText(t) }, t.prototype.fillText = function(t, e, i) { var o = this.ctx; "object" == typeof t ? o.drawImage(t, e.x - t.width / 2, e.y - t.height / 2, t.width, t.height) : (o.fillStyle = i, o.textBaseline = "top", o.textAlign = "center", o.fillText(t, e.x, e.y - this.fontSize / 2)) }, t.prototype.loadImage = function(t) { var e = new Image; return e.src = t.src, e.width = t.width, e.height = t.height, e }, t.prototype.drawArcText = function(t, e, i, o) {
            var s = this.ctx,
                a = i.x,
                r = i.y,
                n = i.startAngle,
                h = i.endAngle;
            s.save(), s.translate(a, r);
            var l = h - n;
            n += Math.PI / 2, h += Math.PI / 2;
            var f = n,
                c = this.measureText(t);
            if (n += (h - (c.width / e + n)) / 2, !o && h - n > l) s.restore();
            else {
                if ("string" == typeof t) {
                    s.rotate(n);
                    for (var d = 0; d < t.length; d++) {
                        var p = t.charAt(d);
                        c = s.measureText(p), s.save(), s.translate(0, -1 * e), s.fillText(p, 0, 0), s.restore(), s.rotate(c.width / e)
                    }
                } else s.rotate((f + h) / 2), s.translate(0, -1 * e), this.fillText(t, { x: 0, y: 0 });
                s.restore()
            }
        }, Chart.pluginService.register({ beforeInit: function(e) { e.pieceLabel = new t }, beforeDatasetsUpdate: function(t) { t.pieceLabel.beforeDatasetsUpdate(t) }, afterDatasetsDraw: function(t) { t.pieceLabel.afterDatasetsDraw(t) } })
    } else console.warn("Can not find Chart object.");

    function t() { this.drawDataset = this.drawDataset.bind(this) }
}();